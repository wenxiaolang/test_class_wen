#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//输出是什么？？？

int main()
{
    char a = -1;
    //11111111111111111111111111111111   -1的补码
    //11111111  因为是char类型，拿出8位，最后我们要打印整型，所以要整型提升
    //11111111111111111111111111111111   整型提升之后，这是补码，原码结果为-1

    signed char b = -1;
    //11111111   和a一样，都是有符号

    unsigned char c = -1;
    //11111111 c为无符号
    //00000000000000000000000011111111  整型提升（补码）正数原，反，补一样  结果为255
    printf("a=%d,b=%d,c=%d", a, b, c);
    //       -1    -1   255
    return 0;
}


//int main()
//{
//    //char的范围为-128-127
//    char a = -128;
//    //10000000 00000000 00000000 10000000    -128原码
//    //11111111 11111111 11111111 01111111        反码
//    //11111111 11111111 11111111 10000000        补码
//    //10000000   char类型，需要整型提升
//    //11111111 11111111 11111111 10000000  整型提升之后，但要打印是无符号类型，这时补码等于原码，原码直接打印
//    printf("%u\n", a);  //4294967168
//    return 0;
//}


//int main()
//{
//    char a = 128;   //char类型的范围为-128-127，就相当于127+1 == -128 （把-128-->127想象一个圈，0->127，-128->-1）
//    printf("%u\n", a);  //4294967168
//    return 0;
//}


//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	//10000000 00000000 00000000 00010100  -20原码
//	//11111111 11111111 11111111 11101011     反码
//	//11111111 11111111 11111111 11101100     补码
//
//	//00000000 00000000 00000000 00001010     10的补码
//	
//	//11111111 11111111 11111111 11110110     结果之和补码
//	//11111111 11111111 11111111 11110101     反码
//	//10000000 00000000 00000000 00001010     原码 结果为-10
//	printf("%d\n", i + j);  //-10
//	return 0;
//}


//#include <Windows.h>
//int main()
//{
//	unsigned int i;
//	//无符号的整型，都是大于等于0，满足条件，死循环
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//9 8 7 6 5 4 3 2 1 很大数（-1）。。死循环
//		Sleep(1000);
//	}
//	return 0;
//}


//int main()
//{
//    char a[1000];
//    int i;
//    for (i = 0; i < 1000; i++)
//    {
//        a[i] = -1 - i;  //原本是-1 -2  -3.....   -1000
//        //但a是char类型，范围为-128->127
//        //-1 -2 -3 .....-128 127 126.....3 2 1 0 ...后面循环
//        //但strlen找到'\0'(也就是0)就停止.所以就是-1>-128,127->1 == 255
//    }
//    printf("%d", strlen(a));  //255
//    return 0;
//}



//unsigned char i = 0;
////无符号的char类型的范围为0-255
//int main()
//{
//    for (i = 0; i <= 255; i++)   //一直满足条件，所以死循环
//    {
//        printf("hello world\n");
//    }
//    return 0;
//}

//计算1/1+1/2+1/3+1/4+1/5......+1/99+1/100
//int main()
//{
//	int i = 0;  //控制分母
//	double sum = 0; //
//	for (i = 1; i <= 100; i++)
//	{
//		sum += 1.0 / i;
//	}
//	printf("sum=%lf", sum);
//	return 0;
//}

////计算1/1-1/2+1/3-1/4+1/5......+1/99-1/100
//int main()
//{
//	int i = 0;
//	double sum = 0;
//	int flag = 1;  //控制正负号
//	for (i = 1; i <= 100; i++)
//	{
//		sum = sum + flag * (1.0 / i);
//		flag = -flag;
//	}
//	printf("sum=%lf", sum);
//}


////求10个整数中最大值
//int main()
//{
//	int arr[] = { -1,-2,-3,-4,-5,-6,-7,-8,-9,-10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int max = arr[0];  //假设将arr[0]的元素设为最大值
//	int i = 0;
//	for (i = 1; i < sz; i++)
//	{
//		if (max < arr[i])
//		{
//			max = arr[i];
//		}
//	}
//	printf("max=%d", max);
//
//	return 0;
//}
